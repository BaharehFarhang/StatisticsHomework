<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lebesgue vs Riemann Integration – Uniform Distribution Mean</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      line-height: 1.6;
    }
    input {
      margin: 5px 0;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Lebesgue vs Riemann Integration</h1>
  <p>
    This example computes the mean of a uniform distribution on the interval [a, b] using two methods:
  </p>
  <ul>
    <li>
      <strong>Riemann Integration:</strong> A left‐point approximation of
      <code>∫[a,b] x · (1/(b–a)) dx</code>.
    </li>
    <li>
      <strong>Lebesgue Integration:</strong> The layer‐cake representation:
      <code>∫₀^(f(b)) m({x in [a, b] : f(x) > y}) dy</code> where <code>f(x) = x · (1/(b–a))</code>.
    </li>
  </ul>
  <p>
    <em>Note:</em> For the Lebesgue approach, we require <code>a ≥ 0</code> so that <code>f(x)</code> is nonnegative.
  </p>

  <h2>Input Parameters</h2>
  <label for="startA">a (start of interval): </label>
  <input type="number" id="startA" value="0" step="any"><br>
  <label for="endB">b (end of interval): </label>
  <input type="number" id="endB" value="10" step="any"><br>
  <label for="riemannSteps">Number of Points (Riemann): </label>
  <input type="number" id="riemannSteps" value="10000"><br>
  <label for="layerLevels">Number of Levels (Lebesgue): </label>
  <input type="number" id="layerLevels" value="10000"><br>
  <button onclick="handleRun()">Compute Mean</button>

  <h2>Results</h2>
  <pre id="report"></pre>

  <script type="text/javascript">
    "use strict";

    /**
     * Left-endpoint Riemann sum for ∫_a^b f(x) dx.
     */
    const riemannLeft = (fn, a0, b0, nSub) => {
      const h = (b0 - a0) / nSub;
      let total = 0;
      for (let i = 0; i < nSub; i++) {
        const xi = a0 + i * h;
        total += fn(xi) * h;
      }
      return total;
    };

    /**
     * Length of { x in [a,b] : f(x) > y } for f(x)=x/(b-a) (monotone ↑).
     */
    const superLevelLength = (levelY, a0, b0) => {
      const x0 = levelY * (b0 - a0); // threshold
      if (x0 <= a0) return b0 - a0;
      if (x0 >= b0) return 0;
      return b0 - x0;
    };

    /**
     * Layer-cake approximation for f(x)=x/(b-a):
     * ∫₀^{sup f} m({f>y}) dy
     */
    const layerCakeIntegral = (a0, b0, kLevels) => {
      const supG = b0 / (b0 - a0);
      const dy = supG / kLevels;
      let acc = 0;
      for (let j = 0; j < kLevels; j++) {
        const yk = j * dy;
        const len = superLevelLength(yk, a0, b0);
        acc += yk * len * dy; // (kept same structure as your original)
      }
      return acc;
    };

    /**
     * Uniform density on [a,b].
     */
    const pdfUniform = (x, a0, b0) => (x < a0 || x > b0 ? 0 : 1 / (b0 - a0));

    /**
     * Mean of U(a,b) via selected method.
     */
    const meanEstimator = (a0, b0, n, methodFn) => {
      const integrand = (x) => x * pdfUniform(x, a0, b0);
      if (methodFn === riemannLeft) {
        return methodFn(integrand, a0, b0, n);
      }
      if (methodFn === layerCakeIntegral) {
        return methodFn(a0, b0, n);
      }
      return 0;
    };

    /**
     * Read inputs → validate → compute → display.
     */
    const handleRun = () => {
      const a0 = parseFloat(document.getElementById('startA').value);
      const b0 = parseFloat(document.getElementById('endB').value);
      const nR = parseInt(document.getElementById('riemannSteps').value, 10);
      const nL = parseInt(document.getElementById('layerLevels').value, 10);

      if (isNaN(a0) || isNaN(b0) || isNaN(nR) || isNaN(nL) || b0 <= a0 || nR <= 0 || nL <= 0) {
        alert("Please enter valid inputs. Ensure that b > a and subdivisions > 0.");
        return;
      }
      if (a0 < 0) {
        alert("For the Lebesgue integration approach, please ensure that a ≥ 0.");
        return;
      }

      const meanR = meanEstimator(a0, b0, nR, riemannLeft);
      const meanL = meanEstimator(a0, b0, nL, layerCakeIntegral);
      const diff = Math.abs(meanR - meanL);
      const exact = (a0 + b0) / 2;

      const out = `Results:
==========
Interval: [${a0}, ${b0}]
Number of Points (Riemann): ${nR}
Number of Levels (Lebesgue): ${nL}

Mean using Riemann Integral: ${meanR.toFixed(6)}
Mean using Lebesgue Integral: ${meanL.toFixed(6)}
Difference: ${diff.toFixed(6)}

Analytical Mean: ${exact.toFixed(6)}`;

      document.getElementById('report').textContent = out;
    };
  </script>
</body>
</html>
